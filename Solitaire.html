<html>
<head>
<title>Solitaire</title>
<style type=text/css>

@font-face {
	font-family: Futura;
	src: url("http://panopo.ly/FuturaStd-Bold.otf") format("opentype");
}

.Card
{
	display:	inline-block;
	padding:	1vmin;
	width:		22vmin;
	height:		calc( 22vmin * 96 / 71 );
	border:		solid #000 1px;
	text-align:	center;
	font-size:	4vmin;
	font-family:	Futura, Arial;
	white-space: nowrap;
	overflow:	hidden;
	background-size:	cover;
	background-color: #fff;
	cursor:	hand;
}

/* cascading */
#ScratchDeckHolder .Deck .Card
{
	margin:		0 0 -25vmin 0;
}


#NewCardDeck .Card
{
	margin:		0 -10vmin 0 0;
}


.Hand:after
{
	content:	'';
	display:	block;
	clear:		both;
}

body
{
	padding:	0px;
}

.DeckHolder, #DeckTopRow
{
	margin:		1vmin;
	display:	flow-root;
}

.Deck
{
	xxxposition:	relative;	/* make children have an absolute relative to us */
	margin:		1vmin;
	padding:	0;
	
	float:		left;
	width:		26vmin;
	height:		calc( 26vmin * 96 / 71 );
	background-color: #2C2;
}

#SuitDeckHolder
{
	float:	right;
}

#NewCardDeckHolder
{
	float:	left;
}

#NewCardDeck
{
	width:		calc(22vmin * 5);
	padding:	2vmin 2vmin 2vmin 10vmin;
}

</style>
</head>
<body>

<div id=DeckTopRow>
	<div id=NewCardDeckHolder class=DeckHolder>
		<div class=Deck id=NewCardDeck></div>
	</div>

	<div id=SuitDeckHolder class=DeckHolder>
		<div class=Deck id=HeartDeck></div>
		<div class=Deck id=SpadeDeck></div>
		<div class=Deck id=DiamondDeck></div>
		<div class=Deck id=ClubDeck></div>
	</div>
</div>

<div id=ScratchDeckHolder class=DeckHolder>
	<div class=Deck id=ScratchDeck0></div>
	<div class=Deck id=ScratchDeck1></div>
	<div class=Deck id=ScratchDeck2></div>
	<div class=Deck id=ScratchDeck3></div>
	<div class=Deck id=ScratchDeck4></div>
	<div class=Deck id=ScratchDeck5></div>
	<div class=Deck id=ScratchDeck6></div>
</div>

<script>

	function float2(_x,_y)
	{
		return {x:_x, y:_y };
	}

	function SetElementPosition(Element,x,y)
	{
		Element.style.position = 'absolute';
		Element.style.top = ( y) + "px";
		Element.style.left = ( x) + "px";
	}

	function SetElementToTop(Element)
	{
		HighestZ++;
		Element.style.zIndex = HighestZ;
	}

	function GetElementRect(Element)
	{
		return Element.getBoundingClientRect();
		let absolutePosition = GetElementRect;
		let el = Element;
		//	need to cope with scroll, not just getBoundingClientRect :/
		//	https://stackoverflow.com/a/32623832/355753
		let
		found,
		left = 0,
		top = 0,
		width = 0,
		height = 0,
		offsetBase = absolutePosition.offsetBase;
		if (!offsetBase && document.body) {
			offsetBase = absolutePosition.offsetBase = document.createElement('div');
			offsetBase.style.cssText = 'position:absolute;left:0;top:0';
			document.body.appendChild(offsetBase);
		}
		if (el && el.ownerDocument === document && 'getBoundingClientRect' in el && offsetBase) {
			let boundingRect = el.getBoundingClientRect();
			let baseRect = offsetBase.getBoundingClientRect();
			found = true;
			left = boundingRect.left - baseRect.left;
			top = boundingRect.top - baseRect.top;
			width = boundingRect.right - boundingRect.left;
			height = boundingRect.bottom - boundingRect.top;
		}
		return {
			found: found,
			left: left,
			top: top,
			width: width,
			height: height,
			right: left + width,
			bottom: top + height,
			x: left,
			y: top,
			xy: float2(left,top)
		};
	}

	function MakeElementAbsolute(Element)
	{
		if ( Element.style.position == "absolute" )
		{
			//console.log("Already absolute");
			return;
		}
		
		//	get current pos
		let Rect = GetElementRect(Element);
		Element.style.position = "absolute";
		Element.style.left = Rect.left + "px";
		Element.style.top = Rect.top + "px";
		document.body.appendChild(Element);
	}

	function SetElementPosition(Element,x,y)
	{
		MakeElementAbsolute(Element);
		
		//	don't allow element off-window
		let Rect = GetElementRect(Element);
		let ElementWidth = Rect.width;
		let ElementHeight = Rect.height;
		let ScreenSize = float2( Element.parentNode.clientWidth, Element.parentNode.clientHeight );
		let ScreenMin = float2(0,0);
		let ScreenMax = float2(ScreenSize.x - ElementWidth, ScreenSize.y - ElementWidth );
		x = Math.max( ScreenMin.x, x );
		y = Math.max( ScreenMin.y, y );
		x = Math.min( ScreenMax.x, x );
		y = Math.min( ScreenMax.y, y );
		
		Element.style.left = x + "px";
		Element.style.top = y + "px";
	}

	function SetElementParent(Element,Parent,NewPos)
	{
		//	make absolute (to detatch from current parent)
		MakeElementAbsolute(Element);
	
		//	leave as absolute if body
		if ( Parent == document.body )
			return;
		
		//	make element relative again
		let ParentRect = GetElementRect(Parent);
		let ChildRect = GetElementRect(Element);
		Parent.appendChild(Element);
		Element.style.position = "inherit";
		/*
		ChildRect.x -= ParentRect.x;
		ChildRect.y -= ParentRect.y;
		Element.style.left = ChildRect.x + "px";
		Element.style.top = ChildRect.y + "px";
		 */

		console.log( Element.className + " new parent " + Parent.className );
	}

	//	returns [float2].snapPos [function].callback [Element].newParent
	function GetDropCallback(Element)
	{
		//	there is no function for getting all elements under a rect,
		//	so instead we'll check the corners
		//	for now that'll probably be enough, if we get some thin places to drop, may we'll have to check a grid of the rect
		let ElementRect = GetElementRect(Element);
		let Min = float2( ElementRect.x, ElementRect.y );
		let Max = float2( Min.x + ElementRect.width, Min.y + ElementRect.height );
		
		let CheckPositions = [];
		CheckPositions.push( float2(Min.x,Min.y) );
		CheckPositions.push( float2(Min.x,Max.y) );
		CheckPositions.push( float2(Max.x,Max.y) );
		CheckPositions.push( float2(Max.x,Min.y) );
		
		let ShadowElements = [];
		let PushUniqueElement = function(ShadowElement)
		{
			let ExistingIndex = ShadowElements.indexOf( ShadowElement );
			if ( ExistingIndex >= 0 )
				return;
			//	filter droppable
			if ( ShadowElement.GetDropPos == undefined )
				return;
			ShadowElements.push( ShadowElement );
		};
		let EnumElementsUnderPoint = function(Point)
		{
			let PointShadows = document.elementsFromPoint(Point.x,Point.y);
			PointShadows.forEach( PushUniqueElement );
		};
		CheckPositions.forEach( EnumElementsUnderPoint );
		
		//	pick best shadow element
		let DroppableShadowElements = [];
		let UndroppableShadowElements = [];

		let CheckDroppable = function(ShadowElement)
		{
			let DropPos = ShadowElement.GetDropPos(Element);
			if ( DropPos == null )
				UndroppableShadowElements.push( ShadowElement );
			else
				DroppableShadowElements.push( ShadowElement );
		};
		ShadowElements.forEach( CheckDroppable );

		//	todo: sort z somehow
		
		if ( DroppableShadowElements.length > 0 )
		{
			let NewParent = DroppableShadowElements[0];
			let DropPos = NewParent.GetDropPos(Element);
			let DropFunc = NewParent.OnDrop;
			return { snapPos:DropPos, callback:DropFunc, newParent:NewParent };
		}

		if ( UndroppableShadowElements.length > 0 )
		{
			return null;
		}
		
		return null;
	}

	function MakeElementDraggable(Element)
	{
		let OnMouseDrag = function(e)
		{
			e = e || window.event;
			
			e.preventDefault();

			let MouseX = e.clientX;
			let MouseY = e.clientY;
			
			let NewX = MouseX - Element.grabLocalX;
			let NewY = MouseY - Element.grabLocalY;
			SetElementPosition( Element, NewX, NewY );
			
			let Droppable = GetDropCallback(Element);
			if ( Droppable != null )
			{
				//	dont snap if dragging FROM this element
				if ( Element.grabParent != Droppable.newParent )
				{
					//	snap!
					NewX = Droppable.snapPos.x;
					NewY = Droppable.snapPos.y;
				}
			}
			
			SetElementPosition( Element, NewX, NewY );
		};

		let OnMouseUp = function(e)
		{
			OnMouseDrag(e);

			//	drop!
			let Droppable = GetDropCallback(Element);
			if ( Droppable != null )
			{
				console.log("on drop " + Droppable.snapPos.x);
				//	do snap in case we skipped it earlier
				SetElementPosition( Element, Droppable.snapPos.x, Droppable.snapPos.y );
				
				//	do drop
				Droppable.callback(Element);
			}
			else
			{
				//	revert the drag
				if ( Element.OnGrabRevert != null )
				{
					Element.OnGrabRevert();
				}
			}
			Element.OnGrabRevert = null;
			
			Element.onmouseup = null;
			Element.onmousemove = null;
			document.onmouseup = null;
			document.onmousemove = null;
		};

		let OnMouseDown = function(e)
		{
			e = e || window.event;
			
			//	grab from parent. This returns null if it can't be dragged.
			//	otherwise returns a revert func
			let Parent = Element.parentNode;
			if ( Parent.OnDetachElement == null )
			{
				console.log(Parent);
				console.log("#" + Parent.id + "." + Parent.className + " has no OnDetachElement func");
				return;
			}
			
			Element.OnGrabRevert = Parent.OnDetachElement( Element );
			if ( Element.OnGrabRevert == null )
			{
				console.log("#" + Parent.id + "." + Parent.className + " disallowed detatch");
				return;
			}
			
			e.preventDefault();
			
			//	jump to top
			Element.grabParent = Element.parentNode;
			SetElementToTop(Element);
			
			Element.grabClientX = e.clientX;
			Element.grabClientY = e.clientY;
			let ClientRect = GetElementRect(Element);
			Element.grabLocalX = Element.grabClientX - ClientRect.x;
			Element.grabLocalY = Element.grabClientY - ClientRect.y;
			Element.startDragX = ClientRect.x;
			Element.startDragY = ClientRect.y;
			
			//	convert element to absolute
			SetElementPosition( Element, Element.startDragX, Element.startDragY );

			Element.onmouseup = OnMouseUp;
			Element.onmousemove = OnMouseDrag;
			//	capture document mouse up in case the user drags off-window
			document.onmouseup = OnMouseUp;
			//	capture document mouse move for when the user moves the mouse so fast it goes off the element, and we don't get mousemove any more
			document.onmousemove = OnMouseDrag;
		};
		
		Element.onmousedown = OnMouseDown;
	}











	function CreateSuit(_Name,_Colour)
	{
		return { Name:_Name, Colour:_Colour };
	}

	var HighestZ = 1;
	var $Red = 'red';
	var $Black = 'black';
	var $Jack = 11;
	var $Queen = 12;
	var $King = 13;
	var $Ace = 14;
	var $Diamond = CreateSuit('Diamond',$Red);
	var $Heart = CreateSuit('Heart',$Red);
	var $Spade = CreateSuit('Spade',$Black);
	var $Club = CreateSuit('Club',$Black);

	function GetLabel(Number)
	{
		if ( Number == $Jack )	return "Jack";
		if ( Number == $Queen )	return "Queen";
		if ( Number == $King )	return "King";
		if ( Number == $Ace )	return "Ace";
		return Number;
	}


	function CreateCard(Number,Suit)
	{
		var Card = document.createElement('div');
		Card.className = 'Card';
		
		var ImageUrl = 'Card_' + Suit.Name + GetLabel(Number) + '.png';
		Card.style.backgroundImage = 'url("' + ImageUrl + '")';
		Card.appendChild( document.createTextNode( GetLabel(Number) + ' ' + Suit.Name ) );
		Card.Suit = Suit;
		Card.Number = Number;
		
		MakeElementDraggable( Card );
		
		return Card;
	}

	function VminToPx(Value)
	{
		let vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
		let vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
		let vmin = Math.min( vw, vh ) / 100;
		ValuePx = vmin * Value;
		return ValuePx;
	}

	function GetElementStyle(Element)
	{
		//	https://stackoverflow.com/a/14275343/355753
		return Element.currentStyle || window.getComputedStyle(Element);
	}

	function GetLastChild(Element,Default)
	{
		if ( Element.children.length == 0 )
			return Default;
		return Element.children[Element.children.length-1];
	}

	function InitDeck(DeckElement)
	{
		DeckElement.GetDropPos = function(Element)
		{
			if ( !DeckElement.CanAcceptCard(Element) )
				return null;
			
			//	get rect of the last element we'll be dropped on
			//	todo: maybe DOM/js has a specific func for that
			//	^^ create an element get it's pos and delete it again
			let LastChild = GetLastChild(DeckElement,DeckElement);
			
			let MarginTop = parseFloat(GetElementStyle(LastChild).marginTop);
			let MarginBottom = parseFloat(GetElementStyle(LastChild).marginBottom);
			let Offset = float2( 0, MarginBottom );

			let DeckRect = GetElementRect(LastChild);
			//	new position will be after the last child
			DeckRect.y += DeckRect.height;
			
			return float2( DeckRect.x+Offset.x, DeckRect.y+Offset.y );
		};
		
		DeckElement.OnDrop = function(Element)
		{
			console.log("ondrop " + Element);
			SetElementParent( Element, DeckElement );
		};
	}


	var UnusedCardPile = InitCardPile();

	function RandomRange(Min,MaxInclusive)
	{
		let Count = MaxInclusive - Min;
		let Randomf = Math.random();
		let Randomi = Math.floor( Randomf * Count );
		let Rand = Min + Randomi;
		return Rand;
	}

	function InitCardPile()
	{
		let Numbers = [ 2,3,4,5,6,7,8,9,$Jack,$Queen,$King,$Ace ];
		let Suits = [ $Heart, $Diamond, $Club, $Spade ];
		let Cards = [];
		let AllocSuitCards = function(Suit)
		{
			let AllocSuitCard = function(Number)
			{
				Cards.push( CreateCard(Number,Suit) );
			};
			Numbers.forEach( AllocSuitCard );
		};
		Suits.forEach( AllocSuitCards );
		return Cards;
	}

	function GetRandomUnusedCard()
	{
		if ( UnusedCardPile.length == 0 )
			return null;
		let Index = RandomRange( 0, UnusedCardPile.length-1 );
		let RandomCard = UnusedCardPile[Index];
		UnusedCardPile.splice(Index, 1);
		return RandomCard;
	}

	function InitScratchDeck(DeckElement,CardStackCount)
	{
		//	put cards on the deck
		for ( let i=0;	i<CardStackCount;	i++ )
		{
			let RandomCard = GetRandomUnusedCard();
			SetElementParent( RandomCard, DeckElement );
		}
		
		let CanAcceptCard = function(Element)
		{
			let LastChild = GetLastChild( DeckElement, null );
			let RequiredNumber = (LastChild == null) ? $King : LastChild.Number-1;
			if ( Element.Number != RequiredNumber )
			{
				console.log("Element.Number (" + Element.Number + ") != RequiredNumber(" + RequiredNumber + ")");
				return false;
			}
			return true;
		};
		DeckElement.CanAcceptCard = CanAcceptCard;
		
		InitDeck( DeckElement );
	}

	function InitSuitDeck(DeckElement,Suit)
	{
		DeckElement.Suit = Suit;
		
		let CanAcceptCard = function(Element)
		{
			if ( Element.Suit != Suit )
				return false;
			return true;
		};
		DeckElement.CanAcceptCard = CanAcceptCard;
		
		InitDeck( DeckElement );
	}

	function InitNewCardDeck(DeckElement)
	{
		//	click to spawn card
		let OnNewCardDeckClick = function(e)
		{
			e = e || window.event;
			e.preventDefault();
			
			let RandomCard = GetRandomUnusedCard();
			if ( RandomCard == null )
			{
				//	todo: recycle deck
				console.log("Out of cards!");
				return;
			}
			SetElementParent( RandomCard, DeckElement );
		};
		
		let OnDetachElement = function(Element)
		{
			//	if this is the last card, let it be detatched
			let LastChild = GetLastChild(DeckElement,null);
			if ( LastChild == Element )
			{
				let Revert = function()
				{
					SetElementParent( Element, DeckElement );
				};
				return Revert;
			}
			
			//	cannot detatch this element
			return null;
		};
		
		DeckElement.onclick = OnNewCardDeckClick;
		
		DeckElement.OnDetachElement = OnDetachElement;
	}

	function Init()
	{
		let NewCardDeck = document.getElementById('NewCardDeck');
		InitNewCardDeck(NewCardDeck);

		let ScratchDeckIds = ['ScratchDeck0','ScratchDeck1','ScratchDeck2','ScratchDeck3','ScratchDeck4','ScratchDeck5','ScratchDeck6'];
		for ( let i=0;	i<ScratchDeckIds.length;	i++ )
		{
			let ScratchCardDeckElement = document.getElementById(ScratchDeckIds[i]);
			InitScratchDeck(ScratchCardDeckElement,i+1);
		}

		let SuitDeckIds = ['HeartDeck','DiamondDeck','ClubDeck','SpadeDeck'];
		let SuitDeckSuits = [$Heart,$Diamond,$Club,$Spade];
		for ( let i=0;	i<SuitDeckIds.length;	i++ )
		{
			let SuitDeckElement = document.getElementById(SuitDeckIds[i]);
			InitSuitDeck(SuitDeckElement,SuitDeckSuits[i]);
		}

		/*
		let DeckElements = document.getElementsByClassName("Deck");
		for ( var i=0;i<DeckElements.length;i++ )
			InitDeck(DeckElements[i]);
		//[].forEach.call( DeckElements, InitDeck );
		
		let Cards = [];
		Cards.push( CreateCard(7,$Club) );
		Cards.push( CreateCard(8,$Club) );
		Cards.push( CreateCard($Jack,$Club) );
		Cards.push( CreateCard(9,$Diamond) );
		Cards.push( CreateCard($Jack,$Diamond) );
		Cards.push( CreateCard($Queen,$Heart) );
		Cards.push( CreateCard($Jack,$Spade) );
		
		let DeckElement = document.getElementById('Deck');
		var x = 400;
		let PositionCard = function(Card)
		{
			x += 20;
			SetElementPosition( Card.Element, x, 20 );
		};
		Cards.forEach( PositionCard );
		 */
	}

	Init();

</script>

</body>
</html>

